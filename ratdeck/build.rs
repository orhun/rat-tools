//! This build script copies the `memory.x` file from the crate root into
//! a directory where the linker can always find it at build time.
//! For many projects this is optional, as the linker always searches the
//! project root directory -- wherever `Cargo.toml` is. However, if you
//! are using a workspace or have a more complicated build setup, this
//! build script becomes required. Additionally, by requesting that
//! Cargo re-run the build script whenever `memory.x` is changed,
//! updating `memory.x` ensures a rebuild of the application with the
//! new memory settings.

use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    // Put `memory.x` in our output directory and ensure it's
    // on the linker search path.
    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());
    File::create(out.join("memory.x"))
        .unwrap()
        .write_all(include_bytes!("memory.x"))
        .unwrap();
    println!("cargo:rustc-link-search={}", out.display());

    // By default, Cargo will re-run a build script whenever
    // any file in the project changes. By specifying `memory.x`
    // here, we ensure the build script is only re-run when
    // `memory.x` is changed.
    println!("cargo:rerun-if-changed=memory.x");

    if let Err(err) = build_assets(out) {
        panic!("asset build failed: {err}");
    }
}

fn build_assets(out_dir: &Path) -> io::Result<()> {
    let assets_dir = Path::new("assets");
    if !assets_dir.is_dir() {
        return Ok(());
    }

    let mut entries = Vec::new();
    for entry in fs::read_dir(assets_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("png") {
            continue;
        }
        println!("cargo:rerun-if-changed={}", path.display());
        entries.push(path);
    }

    if entries.is_empty() {
        return Ok(());
    }

    let mut out_file = File::create(out_dir.join("assets.rs"))?;
    writeln!(out_file, "// @generated by build.rs")?;

    for png_path in entries {
        let stem = png_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "invalid png filename"))?;
        let const_name = const_name(stem);
        let (width, height) = target_dimensions();
        let raw_path = out_dir.join(format!("{stem}.raw"));

        let status = Command::new("ffmpeg")
            .arg("-y")
            .arg("-i")
            .arg(&png_path)
            .arg("-vf")
            .arg(format!("scale={width}:{height}"))
            .arg("-f")
            .arg("rawvideo")
            .arg("-pix_fmt")
            .arg("rgb565be")
            .arg(&raw_path)
            .status()?;
        if !status.success() {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                format!("ffmpeg failed for {}", png_path.display()),
            ));
        }

        writeln!(
            out_file,
            "pub static {const_name}: ImageRaw<'static, Rgb565> = ImageRaw::new(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/{stem}.raw\")), {width});"
        )?;
    }

    Ok(())
}

fn target_dimensions() -> (u32, u32) {
    // Default to the display's configured size. Override via env vars if needed.
    let width = env::var("RATDECK_IMG_W")
        .ok()
        .and_then(|v| v.parse::<u32>().ok())
        .unwrap_or(160);
    let height = env::var("RATDECK_IMG_H")
        .ok()
        .and_then(|v| v.parse::<u32>().ok())
        .unwrap_or(214);
    (width, height)
}

fn const_name(stem: &str) -> String {
    let mut out = String::with_capacity(stem.len());
    for ch in stem.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        out.push_str("IMAGE");
    }
    out
}
