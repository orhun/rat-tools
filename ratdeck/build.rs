//! This build script copies the `memory.x` file from the crate root into
//! a directory where the linker can always find it at build time.
//! For many projects this is optional, as the linker always searches the
//! project root directory -- wherever `Cargo.toml` is. However, if you
//! are using a workspace or have a more complicated build setup, this
//! build script becomes required. Additionally, by requesting that
//! Cargo re-run the build script whenever `memory.x` is changed,
//! updating `memory.x` ensures a rebuild of the application with the
//! new memory settings.

use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process::Command;

use ratatui::style::Style;
use tui_markdown::StyleSheet;

fn main() {
    // Put `memory.x` in our output directory and ensure it's
    // on the linker search path.
    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());
    File::create(out.join("memory.x"))
        .unwrap()
        .write_all(include_bytes!("memory.x"))
        .unwrap();
    println!("cargo:rustc-link-search={}", out.display());

    // By default, Cargo will re-run a build script whenever
    // any file in the project changes. By specifying `memory.x`
    // here, we ensure the build script is only re-run when
    // `memory.x` is changed.
    println!("cargo:rerun-if-changed=memory.x");

    let slides = match build_slides(out) {
        Ok(slides) => slides,
        Err(err) => {
            panic!("slides build failed: {err}");
        }
    };

    if let Err(err) = build_assets(out, slides) {
        panic!("asset build failed: {err}");
    }
}

fn build_assets(out_dir: &Path, slides: Vec<SlideDef>) -> io::Result<()> {
    let assets_dir = Path::new("assets");
    if !assets_dir.is_dir() {
        return Ok(());
    }

    let mut entries = Vec::new();
    for entry in fs::read_dir(assets_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("png") {
            continue;
        }
        println!("cargo:rerun-if-changed={}", path.display());
        entries.push(path);
    }
    entries.sort();

    if entries.is_empty() {
        return Ok(());
    }

    let mut out_file = File::create(out_dir.join("assets.rs"))?;
    writeln!(out_file, "// @generated by build.rs")?;

    let image_positions = image_positions(&slides);
    let mut mappings = Vec::new();
    for png_path in entries {
        let stem = png_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "invalid png filename"))?;
        let const_name = const_name(stem);
        let position = resolve_position(&image_positions, &png_path);
        let (width, height) = target_dimensions(position, &png_path)?;
        let raw_path = out_dir.join(format!("{stem}.raw"));

        let filter = format!(
            "color=black:size={width}x{height} [bg]; \
             [0:v] scale={width}:{height},format=rgba [fg]; \
             [bg][fg] overlay=0:0,format=rgb565be"
        );
        let status = Command::new("ffmpeg")
            .arg("-y")
            .arg("-i")
            .arg(&png_path)
            .arg("-filter_complex")
            .arg(filter)
            .arg("-frames:v")
            .arg("1")
            .arg("-f")
            .arg("rawvideo")
            .arg("-pix_fmt")
            .arg("rgb565be")
            .arg(&raw_path)
            .status()?;
        if !status.success() {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                format!("ffmpeg failed for {}", png_path.display()),
            ));
        }

        writeln!(
            out_file,
            "pub static {const_name}: ImageRaw<'static, Rgb565> = ImageRaw::new(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/{stem}.raw\")), {width});"
        )?;
        let file_name = png_path
            .file_name()
            .and_then(|s| s.to_str())
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "invalid png filename"))?;
        mappings.push((file_name.to_string(), const_name));
    }

    writeln!(
        out_file,
        "pub fn resolve_image(name: &str) -> Option<&'static ImageRaw<'static, Rgb565>> {{"
    )?;
    writeln!(out_file, "    match name {{")?;
    for (file_name, const_name) in mappings {
        writeln!(out_file, "        \"{file_name}\" => Some(&{const_name}),")?;
    }
    writeln!(out_file, "        _ => None,")?;
    writeln!(out_file, "    }}")?;
    writeln!(out_file, "}}")?;

    Ok(())
}

fn build_slides(out_dir: &Path) -> io::Result<Vec<SlideDef>> {
    let slides_path = Path::new("slides.md");
    println!("cargo:rerun-if-changed={}", slides_path.display());
    let input = fs::read_to_string(slides_path)?;

    let slides = parse_slides(&input).map_err(|msg| io::Error::new(io::ErrorKind::Other, msg))?;

    let mut out_file = File::create(out_dir.join("slides.rs"))?;
    writeln!(out_file, "// @generated by build.rs")?;
    writeln!(out_file, "use alloc::boxed::Box;")?;
    writeln!(out_file, "use alloc::vec::Vec;")?;
    writeln!(out_file, "use core::ops::Deref;")?;
    writeln!(out_file, "use once_cell::race::OnceBox;")?;
    writeln!(out_file, "use ratatui::style::{{Color, Stylize}};")?;
    writeln!(out_file, "use ratatui::text::{{Line, Span}};")?;
    writeln!(out_file)?;
    writeln!(out_file, "pub static SLIDES: Slides = Slides;")?;
    writeln!(out_file)?;
    writeln!(out_file, "pub struct Slides;")?;
    writeln!(out_file)?;
    writeln!(out_file, "impl Deref for Slides {{")?;
    writeln!(out_file, "    type Target = [Slide];")?;
    writeln!(out_file, "    fn deref(&self) -> &'static [Slide] {{")?;
    writeln!(out_file, "        slides()")?;
    writeln!(out_file, "    }}")?;
    writeln!(out_file, "}}")?;
    writeln!(out_file)?;
    writeln!(out_file, "fn slides() -> &'static [Slide] {{")?;
    writeln!(
        out_file,
        "    static SLIDES: OnceBox<Vec<Slide>> = OnceBox::new();"
    )?;
    writeln!(out_file, "    SLIDES.get_or_init(|| {{")?;
    writeln!(out_file, "        let slides: Vec<Slide> = alloc::vec![")?;
    for slide in &slides {
        writeln!(out_file, "            {},", slide.to_rust())?;
    }
    writeln!(out_file, "        ];")?;
    writeln!(out_file, "        Box::new(slides)")?;
    writeln!(out_file, "    }}).as_slice()")?;
    writeln!(out_file, "}}")?;

    Ok(slides)
}

#[derive(Debug)]
enum SlideDef {
    Title {
        title: String,
        background: Background,
    },
    Text {
        title: String,
        markdown: String,
    },
    Image {
        title: String,
        image: String,
        position: ImagePosition,
        width: u32,
        height: u32,
        markdown: String,
    },
}

impl SlideDef {
    fn to_rust(&self) -> String {
        match self {
            SlideDef::Title { title, background } => format!(
                "Slide::Title(TitleSlide {{ title: {}, background: {} }})",
                rust_string(title),
                background.to_rust()
            ),
            SlideDef::Text { title, markdown } => format!(
                "Slide::Text(TextSlide {{ title: {}, text: {} }})",
                rust_string(title),
                markdown_to_rust(markdown)
            ),
            SlideDef::Image {
                title,
                image,
                position,
                width,
                height,
                markdown,
            } => format!(
                "Slide::Image(ImageSlide {{ title: {}, image: {}, position: {}, width: {}, height: {}, text: {} }})",
                rust_string(title),
                rust_string(image),
                position.to_rust(),
                width,
                height,
                markdown_to_rust(markdown)
            ),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Background {
    Waves,
    Aurora,
    Nebula,
    Hyper,
}

impl Background {
    fn to_rust(self) -> &'static str {
        match self {
            Self::Waves => "Background::Waves",
            Self::Aurora => "Background::Aurora",
            Self::Nebula => "Background::Nebula",
            Self::Hyper => "Background::Hyper",
        }
    }
}

fn rust_string(value: &str) -> String {
    let mut out = String::with_capacity(value.len() + 2);
    out.push('"');
    for ch in value.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            c if c.is_control() => {
                use std::fmt::Write as _;
                let _ = write!(out, "\\x{:02x}", c as u32);
            }
            c => out.push(c),
        }
    }
    out.push('"');
    out
}

fn parse_slides(input: &str) -> Result<Vec<SlideDef>, String> {
    let lines: Vec<&str> = input.lines().collect();
    let mut slides = Vec::new();
    let mut current = Vec::new();

    for line in lines {
        if line.trim() == "---" {
            if !current.is_empty() {
                slides.push(parse_slide(&current)?);
                current.clear();
            } else {
                return Err("empty slide before separator".to_string());
            }
        } else {
            current.push(line);
        }
    }
    if !current.is_empty() {
        slides.push(parse_slide(&current)?);
    }
    Ok(slides)
}

fn parse_slide(lines: &[&str]) -> Result<SlideDef, String> {
    let mut idx = 0;
    while idx < lines.len() && lines[idx].trim().is_empty() {
        idx += 1;
    }
    if idx >= lines.len() {
        return Err("empty slide".to_string());
    }

    let header = lines[idx].trim();
    idx += 1;
    let title = header
        .strip_prefix('#')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .ok_or_else(|| "slide must start with '# <title>'".to_string())?
        .to_string();

    let body = &lines[idx..];
    let (background, body) = extract_background(body)?;
    let markdown = body.join("\n");

    let mut first_non_empty = None;
    for (line_idx, line) in body.iter().enumerate() {
        if line.starts_with("<!--") && line.ends_with("-->") {
            continue; // skip comments
        }
        if !line.trim().is_empty() {
            first_non_empty = Some((line_idx, *line));
            break;
        }
    }

    let Some((first_idx, first_line)) = first_non_empty else {
        return Ok(SlideDef::Title { title, background });
    };

    if let Some((alt, image)) = parse_image_syntax(first_line.trim())? {
        validate_image_path(&image)?;
        let position = ImagePosition::from_alt(&alt)?;
        let image_path = Path::new("assets").join(&image);
        let (width, height) =
            target_dimensions(position, &image_path).map_err(|err| err.to_string())?;
        let markdown = body[first_idx + 1..].join("\n");
        return Ok(SlideDef::Image {
            title,
            image,
            position,
            width,
            height,
            markdown,
        });
    }

    Ok(SlideDef::Text { title, markdown })
}

fn extract_background<'a>(lines: &[&'a str]) -> Result<(Background, Vec<&'a str>), String> {
    let mut background = None;
    let mut out = Vec::with_capacity(lines.len());
    for line in lines {
        match parse_background_line(line)? {
            Some(found) => {
                if background.replace(found).is_some() {
                    return Err("multiple background directives in a single slide".to_string());
                }
            }
            None => out.push(*line),
        }
    }
    Ok((background.unwrap_or(Background::Waves), out))
}

fn parse_background_line(line: &str) -> Result<Option<Background>, String> {
    let trimmed = line.trim();
    if !trimmed.starts_with("<!--") || !trimmed.ends_with("-->") {
        return Ok(None);
    }
    let inner = trimmed
        .trim_start_matches("<!--")
        .trim_end_matches("-->")
        .trim();
    let inner = inner
        .strip_prefix("background:")
        .or_else(|| inner.strip_prefix("background: ")); // tolerate space
    let Some(value) = inner else {
        return Ok(None);
    };
    let value = value.trim().to_ascii_lowercase();
    match value.as_str() {
        "waves" => Ok(Some(Background::Waves)),
        "aurora" => Ok(Some(Background::Aurora)),
        "nebula" => Ok(Some(Background::Nebula)),
        "hyper" => Ok(Some(Background::Hyper)),
        other => Err(format!("unsupported background: {other}")),
    }
}

fn parse_image_syntax(line: &str) -> Result<Option<(String, String)>, String> {
    if !line.starts_with("![") {
        return Ok(None);
    }
    let after_alt = line
        .find("](")
        .ok_or_else(|| "invalid image syntax, expected ![alt](path)".to_string())?;
    let alt = &line[2..after_alt];
    let path_start = after_alt + 2;
    let path_end = line[path_start..]
        .find(')')
        .ok_or_else(|| "invalid image syntax, missing ')'".to_string())?
        + path_start;
    if path_end + 1 != line.len() {
        return Err("image syntax must be the only content on its line".to_string());
    }
    let path = &line[path_start..path_end];
    if path.is_empty() {
        return Err("image syntax missing path".to_string());
    }
    Ok(Some((alt.to_string(), path.to_string())))
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ImagePosition {
    Left,
    Center,
    Right,
}

impl ImagePosition {
    fn from_alt(alt: &str) -> Result<Self, String> {
        match alt.trim() {
            "image:left" => Ok(Self::Left),
            "image:center" => Ok(Self::Center),
            "image:right" => Ok(Self::Right),
            "" => Ok(Self::Center),
            other => Err(format!("unsupported image position: {other}")),
        }
    }

    fn to_rust(self) -> &'static str {
        match self {
            Self::Left => "ImagePosition::Left",
            Self::Center => "ImagePosition::Center",
            Self::Right => "ImagePosition::Right",
        }
    }
}

fn validate_image_path(value: &str) -> Result<(), String> {
    let assets_dir = Path::new("assets");
    let path = assets_dir.join(value);
    if path.is_file() {
        return Ok(());
    }
    Err(format!(
        "image path not found: {} (expected at {})",
        value,
        path.display()
    ))
}

fn target_dimensions(position: ImagePosition, png_path: &Path) -> io::Result<(u32, u32)> {
    match position {
        ImagePosition::Center => {
            let (src_w, src_h) = source_dimensions(png_path)?;
            if src_w == 0 || src_h == 0 {
                return Err(io::Error::new(
                    io::ErrorKind::Other,
                    format!("invalid image dimensions for {}", png_path.display()),
                ));
            }
            let max_w = 320u64;
            let max_h = 240u64;
            let src_w = src_w as u64;
            let src_h = src_h as u64;

            let (width, height) = if max_w * src_h <= max_h * src_w {
                let width = max_w;
                let height = (src_h * max_w + (src_w / 2)) / src_w;
                (width, height)
            } else {
                let height = max_h;
                let width = (src_w * max_h + (src_h / 2)) / src_h;
                (width, height)
            };
            Ok((width as u32, height as u32))
        }
        ImagePosition::Left | ImagePosition::Right => Ok((160, 214)),
    }
}

fn image_positions(slides: &[SlideDef]) -> Vec<(String, ImagePosition)> {
    let mut out = Vec::new();
    for slide in slides {
        if let SlideDef::Image {
            image, position, ..
        } = slide
        {
            out.push((image.clone(), *position));
        }
    }
    out
}

fn resolve_position(positions: &[(String, ImagePosition)], png_path: &Path) -> ImagePosition {
    let Some(file_name) = png_path.file_name().and_then(|s| s.to_str()) else {
        return ImagePosition::Left;
    };
    let mut pos = None;
    for (image, position) in positions {
        if image == file_name {
            pos = Some(*position);
            if *position == ImagePosition::Center {
                break;
            }
        }
    }
    pos.unwrap_or(ImagePosition::Left)
}

fn source_dimensions(path: &Path) -> io::Result<(u32, u32)> {
    image::image_dimensions(path)
        .map_err(|err| io::Error::new(io::ErrorKind::Other, format!("image read failed: {err}")))
}

fn const_name(stem: &str) -> String {
    let mut out = String::with_capacity(stem.len());
    for ch in stem.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        out.push_str("IMAGE");
    }
    out
}

#[derive(Clone, Copy)]
struct MarkdownStyle;

impl StyleSheet for MarkdownStyle {
    fn heading(&self, level: u8) -> Style {
        match level {
            1 => Style::new().on_cyan().bold().underlined(),
            2 => Style::new().cyan().bold(),
            3 => Style::new().cyan().bold().italic(),
            4 => Style::new().light_cyan().italic(),
            5 => Style::new().light_cyan().italic(),
            _ => Style::new().light_cyan().italic(),
        }
    }

    fn code(&self) -> Style {
        Style::new().white().on_black()
    }

    fn link(&self) -> Style {
        Style::new().blue().underlined()
    }

    fn blockquote(&self) -> Style {
        Style::new().green()
    }

    fn heading_meta(&self) -> Style {
        // De-emphasize metadata so the heading text stays primary.
        Style::new().dim()
    }

    fn metadata_block(&self) -> Style {
        Style::new().yellow()
    }
}

fn markdown_to_rust(markdown: &str) -> String {
    let text =
        tui_markdown::from_str_with_options(markdown, &tui_markdown::Options::new(MarkdownStyle));
    format!("Box::leak(Box::new({text:?}))")
}
